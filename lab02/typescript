Script started on 2019-09-21 13:38:53-0400
]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ ls
 array.cpp       ArrayTester.cpp  'lab02 hexList data.xlsx'   part2.cpp
 arrayData.txt   ArrayTester.h     main.cpp                   typescript
 array.h         [0m[01;34mDebug[0m             part1.cpp
]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ cat main.cpp part.1  1.cpp part2.cpp array.h aa rray.cpp a [A]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ cat main.cpp part1.cpp part2.cpp array.h array.cpp [K
[K[A]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ cat main.cpp part1.cpp part2.cpp array.h array.cpp A rraT yt Tester.h ArraY yTester.cpp arrayData.txt Debug
/* main.cpp drives the testing of the array operations.
 *  Created on: Sep 20, 2019
 *      Author: Alex Fabiano
 *      Lab01 in cs112 at Calvin U
 */
 
#include "ArrayTester.h"

int main() {
	ArrayTester at;
	at.runTests();
}
/* part1.cpp
 *  Created on: Sep 20, 2019
 *      Author: Alex Fabiano
 *      Lab01 in cs112 at Calvin U
 */
 
#include <iostream>
using namespace std;

//int main() {
//	long double   ldoubleVal;
//	cout << "ldoubleVal: " << &ldoubleVal << endl;
//	cout << "of size " << sizeof(ldoubleVal) << "\n" << endl;
//	double        doubleVal;
//	cout << "doubleVal: " << &doubleVal << endl;
//	cout << "of size " << sizeof(doubleVal) << "\n" << endl;
//	float         floatVal;
//	cout << "floatVal: " << &floatVal << endl;
//	cout << "of size " << sizeof(floatVal) << "\n" << endl;
//	long          longVal;
//	cout << "longVal: " << &longVal << endl;
//	cout << "of size " << sizeof(longVal) << "\n" << endl;
//	int           intVal;
//	cout << "intVal: " << &intVal << endl;
//	cout << "of size " << sizeof(intVal) << "\n" << endl;
//	short         shortVal;
//	cout << "shortVal: " << &shortVal << endl;
//	cout << "of size " << sizeof(shortVal) << "\n" << endl;
//	char          charVal1;
//	cout << "charVal1: " << static_cast<void*>(&charVal1) << endl;
//	cout << "of size " << sizeof(charVal1) << "\n" << endl;
//	char          charVal2;
//	cout << "charVal2: " << static_cast<void*>(&charVal2) << endl;
//	cout << "of size " << sizeof(charVal2) << "\n" << endl;
//	bool          boolVal;
//	cout << "boolVal: " << &boolVal << endl;
//	cout << "of size " << sizeof(boolVal) << "\n" << endl;
//
//	long double * ldPtr;
//	cout << "ldPtr: " << &ldPtr << endl;
//	cout << "of size " << sizeof(ldPtr) << "\n" << endl;
//	double *      dPtr;
//	cout << "dPtr: " << &dPtr << endl;
//	cout << "of size " << sizeof(dPtr) << "\n" << endl;
//	float *       fPtr;
//	cout << "fPtr: " << &fPtr << endl;
//	cout << "of size " << sizeof(fPtr) << "\n" << endl;
//	long *        lPtr;
//	cout << "lPtr: " << &lPtr << endl;
//	cout << "of size " << sizeof(lPtr) << "\n" << endl;
//	int *         iPtr;
//	cout << "iPtr: " << &iPtr << endl;
//	cout << "of size " << sizeof(iPtr) << "\n" << endl;
//	short *       sPtr;
//	cout << "sPtr: " << &sPtr << endl;
//	cout << "of size " << sizeof(sPtr) << "\n" << endl;
//	char *        cPtr;
//	cout << "cPtr: " << &cPtr << endl;
//	cout << "of size " << sizeof(cPtr) << "\n" << endl;
//	bool *        bPtr;
//	cout << "bPtr: " << &bPtr << endl;
//	cout << "of size " << sizeof(bPtr) << "\n" << endl;
//}

///* part2.cpp demonstrates a simple dynamically allocated "C-style" array.
// *  Created on: Sep 20, 2019
// *      Author: Alex Fabiano
// *      Lab01 in cs112 at Calvin U
// */
//
//#include "array.h"
//#include <iostream>
//#include <cassert>
//using namespace std;
//
//int main() {
//	const unsigned SIZE = 5;
//	double *a1 = new double[SIZE];
//	assert( a1 != NULL );
//	initialize(a1, SIZE);
//	cout << "\na1: ";
//	print(a1, SIZE);
//	cout << "\na1 average: " << average(a1, SIZE) << endl;
//	delete [] a1;
//
//	const unsigned SIZE2 = 4;
//	double a2[SIZE2];
//	initialize(a2, SIZE2);
//	cout << "\na2: ";
//	print(a2, SIZE2);
//	cout << "\na2 average: " << average(a2, SIZE2) << endl;
//
//	const unsigned SIZE3 = 6;
//	double a3[SIZE3];
//	double value = 100.0;
//	for (unsigned i = 0; i < SIZE3; i++) {
//		a3[i] = value;
//		value -= 1.0;
//	}
//	cout << "\na3: ";
//	print(a3, SIZE3);
//	cout << "\na3 average: " << average(a3, SIZE3) << endl;
//
//}

/* array.h declares "C style" array operations.
 *  Created on: Sep 20, 2019
 *      Author: Alex Fabiano
 *      Lab01 in cs112 at Calvin U
 */
 
#include <iostream>
#include <cassert>
using namespace std;

void initialize(double *a, unsigned size);

void print(double *a, unsigned size);

double average(double *a, unsigned size);

double sum(double *a, unsigned size);

void read(istream& in, double *a, unsigned size);

void fill(const string& fileName, double *&a, unsigned &numValues);

void resize(double *&a, unsigned oldSize, unsigned newSize);

void concat(double *a1, unsigned size1, double *a2, unsigned size2, double *&a3, unsigned &size3);
/* array.cpp defines "C style" array operations
 *  Created on: Sep 20, 2019
 *      Author: Alex Fabiano
 *      Lab01 in cs112 at Calvin U
 */
 
#include "array.h"
#include <fstream>
#include <iostream>
using namespace std;
#include <cassert>
#include <string>

void initialize(double *a, unsigned size) {
	int val = 0;
	for (unsigned i = 0; i < size; i++) {
		val = i+1;
		a[i] = val;
	}
}
//print outputs every value in an array it is sent of given size
//returns nothing
//requires an array of doubles and a size of type unsigned
void print(double *a, unsigned size) {
	for (unsigned i = 0; i < size; i++) {
		cout << *a << '\t';
		a++;
	}
}		
//average adds together every value in an array, a, of given size, size, then divides that number by size
//returns the average value of all the numbers in the array in type double
//requires an array of doubles and a size of type unsigned
double average(double *a, unsigned size) {
	double averageOfGiven = 0;
	for (unsigned i = 0; i < size; i++) {
		averageOfGiven += *a;
		a++;
	}
	averageOfGiven /= size;
	return averageOfGiven;
}
//sum adds together every value in an array, a, of given size, size
//returns a double containing the sum of all the values of the array combined
//requires an array of doubles and a size of type unsigned
double sum(double *a, unsigned size) {
	double sumOfGiven = 0;
	for (unsigned i = 0; i < size; i++) {
		sumOfGiven += *a;
		a++;
	}
	return sumOfGiven;
}
//read reads values from an istream into the array given, a
//returns nothing
//requires an istream, an array of doubles, and a size of type unsigned
void read(istream& in, double *a, unsigned size) {
	for (unsigned i = 0; i < size; i++) {
		string toNumValues;
		getline(in, toNumValues);
		a[i] = stoul(toNumValues, nullptr, 0);
	}
}
//fill opens an fstream to the filename given, reads the first value as the size of the array it will create, then stores the rest of the values in that array
//fill stores the address of the array in a
//returns nothing
//requires the string of a filename, an array of doubles, and an unsigned
void fill(const string& fileName, double *&a, unsigned &numValues) {
	fstream inFileStr(fileName.c_str(), ios::in);
	assert(inFileStr.is_open());
	string toNumValues;
	getline(inFileStr, toNumValues);
	numValues = stoul(toNumValues, nullptr, 0);
	double* arrayThatCanExpand = nullptr;
	delete[] arrayThatCanExpand;
	arrayThatCanExpand = new double[numValues];
	a = *&arrayThatCanExpand;
	double storageForExpand;
	for (unsigned i = 0; i < numValues; i++) {
		getline(inFileStr, toNumValues);
		storageForExpand = stoul(toNumValues, nullptr, 0);
		arrayThatCanExpand[i] = storageForExpand;
	}
	inFileStr.close();
}
//resize creates a new array given an old array. if the size of the new array is larger than the old one, it takes all the values from the old array and sets any extra
//values to 0. if the new array is smaller than the old array, any values beyond the size of the new array are deleted.
//returns nothing
//requires an array and 2 unsigned sizes
void resize(double *&a, unsigned oldSize, unsigned newSize) {
	double * arrayThatCanExpand = nullptr;
	delete [] arrayThatCanExpand;
	arrayThatCanExpand = a;
	arrayThatCanExpand = new double[newSize];

	if (newSize > oldSize)
	{
		for (unsigned i = 0; i < oldSize; i++) {
			arrayThatCanExpand[i] = a[i];
		}
		for (unsigned i = oldSize; i < newSize; i++) {
			arrayThatCanExpand[i] = 0;
		}
	}
	else if (newSize < oldSize)
	{
		for (unsigned i = 0; i < newSize; i++) {
			arrayThatCanExpand[i] = a[i];
		}
	}
	delete [] a;
	a = arrayThatCanExpand;
}
//concat adds the first 2 arrays together into a dynamically allocated third array.
//returns nothing
//requires 3 arrays of doubles and 3 unsigned sizes.
void concat(double *a1, unsigned size1, double *a2, unsigned size2, double *&a3, unsigned &size3) {
	delete[] a3;
	size3 = size1 + size2;
	a3 = new double[size3];
	for (unsigned i = 0; i < size1; i++) {
		a3[i] = a1[i];
	}
	unsigned a2Counter = 0;
	for (unsigned i = size1; i < size3; i++) {
		a3[i] = a2[a2Counter];
		++a2Counter;
	}
}
/*ArrayTester.h provides a class to test C-style array operations.
 *  Created on: Sep 20, 2019
 *      Author: Alex Fabiano
 *      Lab01 in cs112 at Calvin U
 */
#ifndef ARRAY_TESTER_H_
#define ARRAY_TESTER_H_

#include "array.h"  // the functions we are testing
#include <iostream>
#include <cassert>
using namespace std;

class ArrayTester
{
public:
	ArrayTester();
	virtual ~ArrayTester();
	void runTests();
	void setup();
	void cleanup();
	void testInitialize();
	void testPrint();
	void testAverage();
	void testSum();
	void testResize();
	void testConcat();
	void testFill();
	void testRead();
private:
	double * a1;
	double * a2;
	double * a3;
};

#endif /*ARRAY_TESTER_H_*/
/* ArrayTester.cpp defines the methods to test C-style array operations.
 *  Created on: Sep 20, 2019
 *      Author: Alex Fabiano
 *      Lab01 in cs112 at Calvin U
 */
 
 #include "ArrayTester.h"
 #include <fstream>
 using namespace std;

ArrayTester::ArrayTester() {
	a1 = a2 = a3 = NULL;
}

ArrayTester::~ArrayTester() {
        cleanup();
}

void ArrayTester::cleanup() {
	delete [] a1; a1 = NULL;
	delete [] a2; a2 = NULL;
	delete [] a3; a3 = NULL;
}

void ArrayTester::runTests() {
	testInitialize();
	testPrint();
	testAverage();
	testSum();
	testResize();
	testConcat();
	testFill();
	testRead();
	cout << "All tests passed!" << endl;
}

void ArrayTester::setup() {
	a1 = new double[3];
	for (unsigned i = 0; i < 3; i++) {
		a1[i] = i+1;
	}
	a2 = new double[4];
	for (unsigned i = 0; i < 4; i++) {
		a2[i] = i+2;
	}
	a3 = new double[5];
	for (unsigned i = 0; i < 5; i++) {
		a3[i] = i+3;
	}
}

void ArrayTester::testInitialize()  {
	cout << "Testing initialize()... " << flush;
	setup();
	initialize(a1, 3);
	for (unsigned i = 0; i < 3; i++) {
		assert( a1[i] == i+1 );
	}
	initialize(a2, 4);
	for (unsigned i = 0; i < 4; i++) {
		assert( a2[i] == i+1 );
	}
	initialize(a3, 5);
	for (unsigned i = 0; i < 5; i++) {
		assert( a3[i] == i+1 );
	}
        cleanup();
	cout << "Passed!" << endl;
}

void ArrayTester::testPrint() {
	cout << "Testing print()... " << flush;
	setup();
	cout << "\nExpecting 3 values: 1, 2, 3..." << endl;
	print(a1, 3);
	cout << "\nExpecting 4 values: 2, 3, 4, 5..." << endl;
	print(a2, 4);
	cout << "\nExpecting 5 values: 3, 4, 5, 6, 7..." << endl;
	print(a3, 5);
        cleanup();
	cout << "\nPassed!" << endl;
}

void ArrayTester::testAverage() {
	cout << "Testing average()... " << flush;
	setup();
	assert( average(a1, 3) == 2  );
	assert( average(a2, 4) == 3.5 );
	assert( average(a3, 5) == 5 );
        cleanup();
	cout << "Passed!" << endl;
}

void ArrayTester::testSum() {
	cout << "Testing sum()... " << flush;
	setup();
	assert( sum(a1, 3) == 6 );
	assert( sum(a2, 4) == 14 );
	assert( sum(a3, 5) == 25 );
        cleanup();
	cout << "Passed!" << endl;
}

void ArrayTester::testResize() {
	cout << "Testing resize()... " << flush;
	setup();
	double * temp1 = a1;
	resize(a1, 3, 7);
	assert( a1 != temp1 );
	for (unsigned i = 0; i < 3; i++) {
		assert( a1[i] == i+1 );
	}
	for (unsigned i = 3; i < 7; i++) {
		assert( a1[i] == 0 );
	}

	double *temp3 = a3;
	resize(a3, 5, 3);
	assert( temp3 != a3 );
	for (unsigned i = 0; i < 3; i++) {
		assert( a3[i] == i+3 );
	}
        cleanup();
	cout << "Passed!  But double-check that you deleted the old array..." << endl;
}

void ArrayTester::testConcat() {
	cout << "Testing concat()... " << flush;
	setup();
	unsigned size1 = 3, size2 = 4, size3 = 5;
	double *temp1 = a1;
	double *temp2 = a2;
	double *temp3 = a3;
	concat(a1, size1, a2, size2, a3, size3);
	assert( temp1 == a1 );
	assert( temp2 == a2 );
        /* the next assertion assumes that the new array's base
         *  address is different from the old array's base address,
         *  which may not be true. If concat() seems to be right,
         *  and passes all assertions except this one, you may
         *  comment out this assertion.
         */
	assert( temp3 != a3 );
	assert( size1 == 3 );
	assert( size2 == 4 );
	assert( size3 == 7 );
	for (unsigned i = 0; i < 3; i++) {
		assert( a3[i] == i+1 );
	}
	unsigned j = 2;
	for (unsigned i = 3; i < 7; i++) {
		assert( a3[i] == j );
		j++;
	}
        cleanup();
	cout << "Passed!  But double-check that you deleted the old array..." << endl;
}


void ArrayTester::testFill() {
	cout << "Testing fill()... " << flush;
	setup();
	unsigned size1 = 3;
	double *temp1 = a1;
	fill("arrayData.txt", a1, size1);
	assert( a1 != temp1 );
	assert( size1 == 6);
	for (unsigned i = 0; i < size1; i++) {
		assert( a1[i] == i+10 );   // values should be 10, 11, 12, 13, 14, 15
	}
        cleanup();
	cout << "Passed!  But double-check that you deleted the old array..." << endl;
}

void ArrayTester::testRead() {
	cout << "Testing read()... " << flush;
	double* a4 = new double[5];        // allocate anonymous array
	ifstream fin("arrayData.txt");
	assert( fin.is_open() );
	string firstLine, secondLine;
	getline(fin, firstLine);           // skip past the '6' that's there for fill()...
	getline(fin, secondLine);          // skip past the '10'
	read(fin, a4, 5);                  // read 5 values instead of 6
	for (unsigned i = 0; i < 5; i++) { // check what we got:
		assert( a4[i] == i+11 );   //  values should be 11, 12, 13, 14, 15,
	}                                  //   so test-values differ from fill()
        delete [] a4;                      // deallocate anonymous array
	cout << "Passed!" << endl;
}

6
10
11
12
13
14
15
cat: Debug: Is a directory
]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ [Kcd d Deug  bug
]0;aaf25@gold11: ~/cs112/lab02/Debug[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02/Debug[00m$ ls
array.d        ArrayTester.o  main.o      part1.d  part2.o
array.o        [0m[01;32mlab02[0m          makefile    part1.o  sources.mk
ArrayTester.d  main.d         objects.mk  part2.d  subdir.mk
]0;aaf25@gold11: ~/cs112/lab02/Debug[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02/Debug[00m$ make all
make: Nothing to be done for 'all'.
]0;aaf25@gold11: ~/cs112/lab02/Debug[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02/Debug[00m$ cd ..
]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ ./Debug/L lab02
Testing initialize()... Passed!
Testing print()... 
Expecting 3 values: 1, 2, 3...
1	2	3	
Expecting 4 values: 2, 3, 4, 5...
2	3	4	5	
Expecting 5 values: 3, 4, 5, 6, 7...
3	4	5	6	7	
Passed!
Testing average()... Passed!
Testing sum()... Passed!
Testing resize()... Passed!  But double-check that you deleted the old array...
Testing concat()... Passed!  But double-check that you deleted the old array...
Testing fill()... Passed!  But double-check that you deleted the old array...
Testing read()... Passed!
All tests passed!
]0;aaf25@gold11: ~/cs112/lab02[01;32maaf25@gold11[00m:[01;34m~/cs112/lab02[00m$ exit

Script done on 2019-09-21 13:41:00-0400
