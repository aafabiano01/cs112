Script started on 2019-10-17 11:14:14-0400
]0;aaf25@maroon17: ~/cs112/proj06[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06[00m$ ls
CongaLine.cpp  lab05CoutTest.txt        ListTester.cpp      main.cpp
CongaLine.h    lab05ReadStringTest.txt  ListTester.h        typescript
conga.txt      List.h                   ListTestWrite1.txt
[0m[01;34mDebug[0m          ListTest1.txt            ListTestWrite2.txt
]0;aaf25@maroon17: ~/cs112/proj06[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06[00m$ cat main.cpp conga.txt           CongaLine.h CongaLine.cpp List.h Lis tTester.h ListTester.cpp *.txt
/* main.cpp is the driver for a Conga line simulation.
 *
 * @author: Joel Adams, for CS 112 at Calvin University.
 *
 * Based on an exercise by Marc LeBlanc from Wheaton College (MS).
 */
#include "ListTester.h"
#include "CongaLine.h"

int main() {
	ListTester lt;
	lt.runTests();
	CongaLine dance("Ann", "Bob");
	dance.run();
}
/* CongaLine.h declares class CongaLine,
 *  a Conga line dance simulation.
 *
 * @author: Joel Adams, for CS 112 at Calvin University.
 *
 * Based on an exercise by Marc LeBlanc from Wheaton College (MS).
 */


#ifndef CONGALINE_H_
#define CONGALINE_H_

#include "List.h"
#include <string>
using namespace std;

class CongaLine {
public:
	CongaLine(const string& person1, const string& person2);
	void run();

private:
	List<string> myLine;

	string MY_MENU;
	string myFirstPerson;
	string mySecondPerson;
};

#endif /* CONGALINE_H_ */
/* CongaLine.cpp defines the methods for class CongaLine.
 *
 * @author: Joel Adams, for CS 112 at Calvin University.
 *
 * Based on an exercise by Marc LeBlanc from Wheaton College (MS).
 */

#include "CongaLine.h"

/* The CongaLine constructor
 * @param: person1, a string
 * @param: person2, a string
 * Postcondition: myFirstPerson == person1
 *             && mySecondPerson == person2
 *             && person1 is the first Item in myLine
 *             && person2 is the second Item in myLine
 *             && MY_MENU has been initialized.
 */
CongaLine::CongaLine(const string& person1, const string& person2) {
	myLine.append(person1);
	myLine.append(person2);
	myFirstPerson = person1;
	mySecondPerson = person2;
	MY_MENU = string("Please enter:\n")
		+ " 1 to join the Conga line at the end\n"
		+ " 2 to join the Conga line after a particular person\n"
		+ " 3 to join the Conga line before a particular person\n"
		+ " 4 to quit\n"
		+ "--> ";
}

/* Method to run the CongaLine simulation,
 *  prompting the user via cout
 *  and reading the user's input via cin.
 */
void CongaLine::run() {
	unsigned menuChoice = 0;
	string yourName, otherPersonsName;
	cout << myFirstPerson << " and " << mySecondPerson
			<< " have started a Conga Line!" << endl;

	while (menuChoice != 4) {
//		cout << "\n " << myLine << "\n\n";
//		cout << "\n"; myLine.writeTo(cout, '='); cout << "\n\n";
		cout << "Conga, Conga, Con-GA!  Conga, Conga, Con-GA!\n" << endl;
		cout << MY_MENU;
		cin >> menuChoice;
		if (menuChoice == 1 || menuChoice == 2 || menuChoice == 3) {
			cout << "\nWhat is your name? ";
			cin >> yourName;
		}

		switch( menuChoice ) {
		case 1:
			myLine.append(yourName);
			break;
		case 2:
			cout << "Who do you want to follow? ";
			cin >> otherPersonsName;
			if ( !myLine.insertAfter(otherPersonsName, yourName) ) {
				cout << "\n***" << otherPersonsName
					 << " is not dancing!\n" << endl;
			}
			break;
		case 3:
			cout << "Who do you want to precede? ";
			cin >> otherPersonsName;
			if ( !myLine.insertBefore(otherPersonsName, yourName) ) {
				cout << "\n***" << otherPersonsName
					 << " is not dancing!\n" << endl;
			}
			break;
		case 4:
			cout << "\nThe dance is done!\n";
			break;
		default:
			cout << "\n*** " << menuChoice
			     << " is not a valid choice!\n" << endl;
		}
		cout << myLine << endl;
	}
}

/* List.h declares and defines methods
 * Student Names: Benedict Jojo Arthur (TM 1) & ALexander Fabiano (TM 2)
 * Date:10/14/2019
 * Proj 05
 *
 */

#ifndef LIST_H_
#define LIST_H_

#include <iostream>
#include <stdexcept>
#include <cassert>
#include <string>
#include <sstream>
#include <fstream>
#include <cstdlib>

using namespace std;
typedef  double Item;
template <class Item>

class List {
public:

	List();
	unsigned getSize() const;
	Item getFirst() const;
	Item getLast() const;
	void append(Item it);
	~List();
	List(const List<Item>& original);
	List<Item>& operator=(const List<Item>& l2);

	bool operator==(const List<Item>& l2);
	void readFrom(istream& cin);
	void writeTo(const string& fileName);
	void prepend(Item it);
	void insert(Item it, int index);

	bool operator!=(const List& original) const;
	void writeTo(ostream& out, string separate) const;
	void readFrom(const string fileName);
	int getIndexOf(const Item lookingFor) const;
	Item remove(unsigned index);

	bool insertAfter(string otherName, string yourName);
	bool insertBefore(string otherName, string yourName);
	/*
	 * operator<<() allows operation chaining with the output symbol when
	 * using lists.
	 * param: an ostream to output to, such as cout, and a list to output
	 * precondition: output is open
	 * return: ostream to allow for operation chaining
	 * postcondition: every value in the list given is printed out starting
	 * with = and with a = between every value.
	 * Made by Alex Fabiano
	 */
    friend ostream &operator<<( ostream &output, const List &myConga ) {
    	output << "=";
    	myConga.writeTo(output, "=");
    	return output;
    }

private:

	unsigned mySize;

	struct Node {
		Node();
		Node(Item it, Node* next);
		Item myItem;
		Node* myNext;

		~Node();
	};
	Node* myFirst;
	Node* myLast;
	friend class ListTester;
};

template <class Item>
List<Item>::List() {
	mySize = 0;
	myFirst = NULL;
	myLast = NULL;
}

template <class Item>
List<Item>::Node::Node() {
	myItem = 0;
	myNext = NULL;
}


template <class Item>
List<Item>::Node::Node(Item it, Node* next) {
	myItem = it;
	myNext = next;
}

template <class Item>
unsigned List<Item>::getSize() const {
	return mySize;
}

template <class Item>
Item List<Item>::getFirst() const {
	if (mySize != 0) {
		return myFirst->myItem;
	} else {
		throw underflow_error("Cannot access values because list is empty");
	}
}

template <class Item>
Item List<Item>::getLast() const {
	if (mySize != 0) {
		return myLast->myItem;
	} else {
		throw underflow_error("Cannot access values because list is empty");
	}
}


template <class Item>
void List<Item>::append(Item it) {
	List::Node* newNodePtr = new List::Node(it, NULL);
	if (mySize == 0) {
		myFirst = newNodePtr;
	} else {
		myLast->myNext = newNodePtr;
	}
	myLast = newNodePtr;
	mySize++;
}

template <class Item>
List<Item>::Node::~Node() {
	delete myNext;
}

template <class Item>
List<Item>::~List() {
	delete myFirst;
	myFirst = myLast = NULL;
	mySize = 0;
}

template <class Item>
List<Item>::List(const List& original) {
	myFirst = myLast = NULL;
	mySize = 0;
	if (original.mySize > 0) {
		Node* oPtr = original.myFirst;
		while (oPtr != NULL) {
			append(oPtr->myItem);
			oPtr = oPtr->myNext;
		}
	}
}

template <class Item>
List<Item>& List<Item>::operator=(const List& original) {
	if (this != &original) {
		delete myFirst;
		mySize = 0;
		myFirst = myLast = NULL;
		if (original.mySize != 0) {
			Node* oPtr = original.myFirst;
			while (oPtr != NULL) {
				append(oPtr->myItem);
				oPtr = oPtr->myNext;
			}
		}
	}
	return *this;
}



/* Equality
 * @params: l2(const List<Item>)
 * Postcondition: Returns true if list objects are the same
 * Done By: Benedict Jojo Arthur
 */


template <class Item>
bool List<Item>::operator==(const List<Item>& l2) {
	if (mySize != l2.mySize) {
		return false;
	} else {
		Node* myPtr = myFirst;
		Node* l2Ptr = l2.myFirst;
		while (myPtr != NULL) {
			if (myPtr->myItem != l2Ptr->myItem) {
				return false;
			}
			l2Ptr = l2Ptr->myNext;
			myPtr = myPtr->myNext;
		}
		return true;
	}
}

/* Stream Input
 * @params: cin (istream)
 * Postcondition: Reads users values and appends to a lists
 * Done By: Benedict Jojo Arthur
 */


template <class Item>
void List<Item>::readFrom(istream& cin) {
	string line;
	getline(cin, line);
	stringstream streamLine(line);
	Item user;
	while (streamLine >> user) {
		append(user);
	}

}


/* File Output
 * @params: fileName (const string)
 * Postcondition: Outputs values in a list to a file
 * Done By: Benedict Jojo Arthur
 */

template <class Item>
void List<Item>::writeTo(const string& fileName) {
	ofstream fout(fileName.c_str());
	Node* myPtr = myFirst;
	for (unsigned i = 0; i < mySize; i++) {
		fout << myPtr->myItem << endl;
		myPtr = myPtr->myNext;
	}
	fout.close();
}


/* Prepend
 * @params: it (Item)
 * Postcondition: Inserts it at the beginning of aList
 * Done By: Benedict Jojo Arthur
 */

template <class Item>
void List<Item>::prepend(Item it) {
	Node* newNodePtr = new List<Item>::Node(it, NULL);
	if (mySize == 0) {
		myLast = newNodePtr;
	} else {
		newNodePtr->myNext = myFirst;
	}
	myFirst = newNodePtr;
	mySize++;
}


/* Insertion
 * @params: it (Item), index (int)
 * Postcondition: insert item it into aList at index index
 * Done By: Benedict Jojo Arthur
 */


template <class Item>
void List<Item>::insert(Item it, int index) {
	if (index <= 0 || mySize == 0) {
		prepend(it);
	} else if (index >= mySize) {
		append(it);
	} else {
		Node* tempPtr = myFirst;
		for (unsigned i = 0; i < index-1; ++i) {
			tempPtr = tempPtr->myNext;
		}
		Node* newNodePtr = new List<Item>::Node(it, tempPtr->myNext);
		tempPtr->myNext = newNodePtr;
		mySize++;
	}

}

/*
 * operator!=() determines whether or not two lists are equal.
 * param: List to compare to other list.
 * precondition: none.
 * return: true or false, true if they are not equal, false if equal.
 * postcondition: neither lists are changed.
 * Made by Alex Fabiano
 */


template <class Item>
bool List<Item>::operator!=(const List& original) const {
    if (mySize != original.mySize) {
        return true;
    } else {
        Node *ogPointer = original.myFirst;
        Node *myPointer = myFirst;
        for (unsigned i = 0; i < mySize; ++i) {
            if (ogPointer->myItem != myPointer->myItem){
                return true;
            }
            ogPointer = ogPointer->myNext;
            myPointer = myPointer->myNext;
        }
    }
    return false;
}


/*
 * writeTo() writes a list to an ostream.
 * param: ostream to write to, separator between values.
 * precondition: ostream is already open.
 * return: nothing.
 * postcondition: the list is not changed, and it has now been printed
 * to the ostream given.
 * Made by Alex Fabiano
 */

template <class Item>
void List<Item>::writeTo(ostream& out, string separate) const {
    Node *myPointer = myFirst;
    if (myPointer != nullptr) {
    	for (unsigned i = 0; i < mySize - 1; ++i) {
    	        out << myPointer->myItem << separate;
    	        myPointer = myPointer->myNext;
    	    }
    	    	out << myPointer->myItem;
    }

}


/*
 * readFrom() reads items from a file and makes a list out of them.
 * param: name of file with extension.
 * precondition: file exists.
 * return: nothing.
 * postcondition: the array readFrom() was enacted on is now a copy
 * of all the values in the file.
 * Made by Alex Fabiano
 */

template <class Item>
void List<Item>::readFrom(const string fileName) {
    Item pickyAppend;
    /*
     * I named the item pickyAppend because I was mad, now I can't even
     * remember why I did.
     */
    ifstream bin(fileName);
    assert( bin.is_open() );
    /*
     * I open two streams, one acts as a counter, while the other takes in
     * values.
     * Because cin automatically increments to the next value, it can't be
     * used as both the counter and the method by which values are stored.
     */
    ifstream fin(fileName);
    assert( fin.is_open() );
    while ( bin >> pickyAppend ) {
        fin >> pickyAppend;
        append(pickyAppend);
    }
}


/*
 * getIndexOf() finds the index of a node given its item value.
 * param: Item to look for.
 * precondition: none.
 * return: The index of the item, or where it was first found if there are
 * more than one. -1 if the item was not found.
 * postcondition: the array is not changed.
 * Made by Alex Fabiano
 */

template <class Item>
int List<Item>::getIndexOf(const Item lookingFor) const {
    int counter = 0;
    Node *myPointer = myFirst;
    for (unsigned i = 0; i < mySize; ++i) {
        if (lookingFor == myPointer->myItem) {
            return counter;
        }
        counter++;
        myPointer = myPointer->myNext;
    }
    return -1;
}

/*
 * remove() removes a node from a list of nodes.
 * param: index at which the node is to be removed.
 * precondition: none.
 * return: none.
 * postcondition: the array remove was enacted on has one less value
 * and whichever index was chosen is removed.
 * Made by Alex Fabiano
 */

template <class Item>
Item List<Item>::remove(unsigned index) {
    if (mySize == 0) {
        /*
         * If size of List is 0, return -1 as the item at the position of the deletion
         * because nothing was there.
         * Very important that this goes first, because trying to do normal methods
         * on a completely null list causes some problems.
        */
        return -1;
    }
    Item itemHolder = myFirst->myItem;
    Node *myPointer = myFirst;
    for (unsigned i = 0; i < index; i++) {
        /*
         * Finds value to return for deleted Item.
         * itemHolder will be the value at the index that was deleted.
         */
        itemHolder = myPointer->myItem;
        myPointer = myPointer->myNext;
    }
    if (mySize == 1) {
        /*
         * Deleting the only value in a list makes it an empty list.
         * Outside of main if statement because its a special case.
         */
        delete myFirst;
        myFirst = myLast = NULL;
        mySize = 0;
        return itemHolder;
    }
    Node *temp = new Node;
    if (index >= mySize) {
        //Deleting tail.
        Node *prev = myFirst;
        /*
         * Always two steps ahead...
         * Basically, the node prev will only advance if the value it will
         * advance to, as well as that value's next value are both not null.
         * If they are, because prev's next's next is null, it must mean
         * prev's next is the last value in the list.
         * So prev's next is "freed" (like a delete without calling the
         * destructor) and prev's myNext pointer becomes null, showing that
         * prev is now the last value in the list.
         */
        while (prev->myNext->myNext != NULL) {
            prev = prev->myNext;
        }
        free(prev->myNext);
        prev->myNext = NULL;
    }
    else if (index == 0){
        //Deleting head.
        temp = myFirst;
        myFirst = myFirst->myNext;
        free(temp);
        /*
         * Temp is a node, but also kind of an alias for the value at myFirst.
         * Setting temp equal to myFirst sets temp as an alias to the node that
         * is referenced by myFirst, so that way, when we change the pointer
         * myFirst to be pointing to the second node in the list, we still have
         * a way to get at the first value in the list and delete it so it is not
         * leaked.
         * 'Freeing' is a lot more important in this case, because if the
         * destructor was called, it would destroy every node in the list.
         */
    }
    else {
        //Deleting from random position.
        temp = myFirst;
        Node *post;
        for (unsigned i = 0; i < index -1; ++i) {
            temp = temp->myNext;
        }
        /*
         * Temp is stopped one node before the node that is to be deleted.
         * Post is set to the node to be deleted.
         * Temp's myNext pointer is set to point to the node after post, the
         * node to be deleted.
         * Like before, post allows us to have a handle on a value that would
         * otherwise be marooned.
         * The value before post now points to the value after post.
         * When we free post, the destructor is not called, and the memory leak
         * is avoided.
         */
        post = temp->myNext;
        temp->myNext = post->myNext;
        free(post);
    }
    mySize--;
    return itemHolder;
}
/*
 * insertAfter() inserts an item a place after a given item.
 * param: 2 strings, first the string to place the string given after,
 * then the string to place behind it.
 * precondition: none.
 * return: true or false, true if the first string is found in the list,
 * false if the first string is not found.
 * postcondition: the second string is now following the first.
 * Made by Alex Fabiano
 */
template <class Item>
bool List<Item>::insertAfter(string otherName, string yourName) {
	unsigned index = getIndexOf(otherName);
	if (index == -1) {
		return false;
		throw "Person not dancing error.";
	}
	insert(yourName, index + 1);
	return true;
}
/*
 * insertBefore() inserts an item a place before a given item.
 * param: 2 strings, first the string to place the string given before,
 * then the string to place before it.
 * precondition: none.
 * return: true or false, true if the first string is found in the list,
 * false if the first string is not found.
 * postcondition: the second string is now preceding the first.
 * Made by Alex Fabiano
 */
template <class Item>
bool List<Item>::insertBefore(string otherName, string yourName) {
	unsigned index = getIndexOf(otherName);
	if (index == -1) {
		return false;
		throw "Person not dancing error.";
	}
	insert(yourName, index);
	return true;
}

#endif /* LIST_H_ */
/* ListTester.h declares the test-class for class List.
 * Joel Adams, for CS 112 at Calvin University.
 * Student Names: Benedict Jojo Arthur (TM 1) & ALexander Fabiano (TM 2)
 * Date:10/14/2019
 * Proj 05
 */

#ifndef LISTTESTER_H_
#define LISTTESTER_H_

class ListTester {
public:
	void runTests();
	void testDefaultConstructor();
	void testNodeDefaultConstructor();
	void testNodeExplicitConstructor();
	void testAppend();
	void testDestructor();
	void testCopyConstructor();
	void testAssignment();

	void testEquality();
	void testReadFromStream();
	void testWriteToString();
	void testPrepend();
	void testInsert();

	void testInequality();
	void testWriteToStream();
	void testReadFromString();
	void testGetIndexOf();
	void testRemove();

	void testInsertAfter();
	void testInsertBefore();
	void testOutput();
};

#endif /*LISTTESTER_H_*/
/* ListTester.cpp defines the test methods for class List.
 * Joel Adams, for CS 112 at Calvin University.
 * Student Names: Benedict Jojo Arthur (TM 1) & ALexander Fabiano (TM 2)
 * Date:10/14/2019
 * Proj 05
 */


#include "ListTester.h" // ListTester
#include "List.h"       // List
#include <iostream>     // cin, cout
#include <cassert>      // assert()
#include <cstdlib>      // exit()
#include <stdexcept>    // underflow_error
using namespace std;

void ListTester::runTests() {
	cout << "Running List tests..." << endl;
	testDefaultConstructor();
	testNodeDefaultConstructor();
	testNodeExplicitConstructor();
	testAppend();
	testDestructor();
	testCopyConstructor();
	testAssignment();
    testEquality();
    testReadFromStream();
    testWriteToString();
    testPrepend();
    testInsert();
    testInequality();
    testWriteToStream();
    testReadFromString();
    testGetIndexOf();
    testRemove();
    testInsertAfter();
    testInsertBefore();
    testOutput();
	cout << "All tests passed!" << endl;
}

void ListTester::testDefaultConstructor() {
	cout << "Testing List default constructor... " << flush;
	List<double> aList;
	assert( aList.mySize == 0 );
	assert( aList.myFirst == NULL );
	assert( aList.myLast == NULL );
	cout << "Passed!" << endl;
}

void ListTester::testNodeDefaultConstructor() {
	cout << "Testing Node default constructor... " << flush;
	List<double>::Node aNode;
	assert( aNode.myItem == Item() );
	assert( aNode.myNext == NULL );
	cout << "Passed!" << endl;
}

void ListTester::testNodeExplicitConstructor() {
	cout << "Testing Node explicit constructor... " << flush;
	List<double>::Node n1(11, NULL);
	assert( n1.myItem == 11 );
	assert( n1.myNext == NULL );
	cout << " 1 " << flush;

	List<double>::Node *n3 = new List<double>::Node(33, NULL);
	List<double>::Node n2(22, n3);
	assert( n2.myItem == 22 );
	assert( n2.myNext == n3 );
	cout << " 2 " << flush;
	cout << "Passed!" << endl;
}

void ListTester::testAppend() {
	cout << "Testing append()... " << flush;
	// empty List
	List<double> aList;
	assert( aList.getSize() == 0 );
	assert( aList.myFirst == NULL );
	assert( aList.myLast == NULL );
	try {
		aList.getFirst();
		cerr << "getFirst() worked on empty list" << endl;
		exit(1);
	} catch (underflow_error&) {
		cout << " 0a " << flush;
	}
	try {
		aList.getLast();
		cerr << "getLast() worked on empty list" << endl;
		exit(1);
	} catch (underflow_error&) {
		cout << " 0b " << flush;
	}
	// append to empty list
	aList.append(11);
	assert( aList.getSize() == 1 );
	assert( aList.myFirst != NULL );
	assert( aList.myLast == aList.myFirst );
	assert( aList.getFirst() == 11 );
	assert( aList.getLast() == 11 );
	assert( aList.myFirst->myNext == NULL );
	cout << " 1 " << flush;
	// append to a list containing 1 Item
	aList.append(22);
	assert( aList.getSize() == 2 );
	assert( aList.myFirst != NULL );
	assert( aList.myLast != NULL );
	assert( aList.myFirst != aList.myLast );
	assert( aList.getFirst() == 11 );
	assert( aList.getLast() == 22 );
	assert( aList.myFirst->myNext != NULL );
	assert( aList.myLast->myNext == NULL );
	cout << " 2 " << flush;
	// append to a list containing 2 Items
	aList.append(33);
	assert( aList.getSize() == 3 );
	assert( aList.myFirst != NULL );
	assert( aList.myLast != NULL );
	assert( aList.getFirst() == 11 );
	assert( aList.getLast() == 33 );
	assert( aList.myFirst->myNext->myItem == 22 );
	assert( aList.myLast->myNext == NULL );
	cout << " 3 " << flush;
	cout << "Passed!" << endl;
}

void ListTester::testDestructor() {
	cout << "Testing destructor... " << flush;
	List<double> aList;
	aList.~List();
	assert( aList.getSize() == 0 );
	assert( aList.myFirst == NULL );
	assert( aList.myLast == NULL );
	cout << " 1 " << flush;

	aList.append(11);
	aList.append(22);
	aList.append(33);
	aList.~List();
	assert( aList.getSize() == 0 );
	assert( aList.myFirst == NULL );
	assert( aList.myLast == NULL );
	cout << " 2 " << flush;
	cout << "Passed!  But double-check for memory leaks!" << endl;
}

void ListTester::testCopyConstructor() {
	cout << "Testing copy constructor... " << flush;
	// copy empty list
	List<double> list1;
	List<double> list2(list1);
	assert( list2.getSize() == 0 );
	assert( list2.myFirst == NULL );
	assert( list2.myLast == NULL );
	cout << " 1 " << flush;

	// copy nonempty list
	List<double> list3;
	list3.append(11);
	list3.append(22);
	list3.append(33);
	List<double> list4(list3);
	assert( list4.getSize() == 3 );
	assert( list4.getFirst() == 11 );
	assert( list4.getLast() == 33 );
	assert( list4.myFirst->myNext->myItem == 22 );
	assert( list4.myFirst != list3.myFirst );
	assert( list4.myLast != list3.myLast );
	cout << " 2 " << flush;
	cout << "Passed!" << endl;
}

void ListTester::testAssignment() {
	cout << "Testing assignment... " << flush;
	// empty to empty assignment
	List<double> list1;
	List<double> list2;
	list2 = list1;
	assert( list2.getSize() == 0 );
	assert( list2.myFirst == NULL );
	assert( list2.myLast == NULL );
	cout << " 1 " << flush;

	// non-empty to empty assignment
	List<double> list3;
	list3.append(11);
	list3.append(22);
	list3.append(33);
	List<double> list4;
	list4 = list3;
	assert( list4.getSize() == 3 );
	assert( list4.getFirst() == 11 );
	assert( list4.getLast() == 33 );
	assert( list4.myFirst->myNext->myItem == 22 );
      // check that nodes are distinct
	assert( list4.myFirst != list3.myFirst );
	assert( list4.myFirst->myNext != list3.myFirst->myNext );
	assert( list4.myLast != list3.myLast );
	cout << " 2 " << flush;

	// equal-sized non-empty to non-empty assignment
	List<double> list5;
	list5.append(44);
	list5.append(55);
	list5.append(66);
	list5 = list3;
	assert( list5.getSize() == 3 );
	assert( list5.getFirst() == 11 );
	assert( list5.getLast() == 33 );
	assert( list5.myFirst->myNext->myItem == 22 );
      // check that nodes are distinct
	assert( list5.myFirst != list3.myFirst );
	assert( list5.myFirst->myNext != list3.myFirst->myNext );
	assert( list5.myLast != list3.myLast );
	cout << " 3 " << flush;

	// empty to non-empty assignment
	List<double> list6;
	list6.append(44);
	list6.append(55);
	list6.append(66);
	List<double> list7;
	list6 = list7;
	assert( list6.getSize() == 0 );
	assert( list6.myFirst == NULL );
	assert( list6.myLast == NULL );
	cout << " 4 " << flush;

	// unequal-sized non-empty to non-empty assignment
	List<double> list8;
	list8.append(44);
	list8.append(55);
	list8.append(66);
	list8.append(77);
	list8 = list3;
	assert( list8.getSize() == 3 );
	assert( list8.getFirst() == 11 );
	assert( list8.getLast() == 33 );
	assert( list8.myFirst->myNext->myItem == 22 );
      // check that nodes are distinct
	assert( list8.myFirst != list3.myFirst );
	assert( list8.myFirst->myNext != list3.myFirst->myNext );
	assert( list8.myLast != list3.myLast );
	cout << " 5 " << flush;

	// assignment chaining
	List<double> list9;
	list9.append(44);
	list9.append(55);
	list9.append(66);
	list9.append(77);
	List<double> list10;
	list10 = list9 = list8;
	assert( list10.getSize() == 3 );
	assert( list10.getFirst() == 11 );
	assert( list10.getLast() == 33 );
	assert( list10.myFirst->myNext->myItem == 22 );
	cout << " 6 " << flush;

	// self-assignment (stupid, but possible)
	List<double> list11;
	list11.append(11);
	list11.append(22);
	list11.append(33);
	list11 = list11; // @suppress("Assignment to itself")
	assert( list11.getSize() == 3 );
	assert( list11.getFirst() == 11 );
	assert( list11.getLast() == 33 );
	assert( list11.myFirst->myNext->myItem == 22 );
	cout << " 7 " << flush;

	cout << "Passed!  But double-check for memory leaks!" << endl;


}

void ListTester::testEquality() {
	cout << "Testing equality... " << flush;
	List<double> list0;
	List<double> list1;
	List<double> list3;

	//both empty
	assert( list0 == list1);
	cout << " 0 " << flush;
	for (unsigned i = 0; i < 3; ++i) {
		list0.append(i+1);
	}
	//one empty list one list with items
	assert( !(list0 == list1) );
	cout << " 1 " << flush;

	//both with items and equal
	for (unsigned i = 0; i < 3; ++i) {
		list1.append(i+1);
	}
	assert( list0 == list1 );
	cout << " 2 " << flush;

	//Equal size different values
	for (unsigned i = 0; i < 3; ++i) {
		list3.append(i+10);
	}
	assert( !(list1 == list3) );
	cout << " 3 " << flush;

	cout << "Passed!" << endl;
}

void ListTester::testReadFromStream() {
	cout << "Testing readFrom(istream)... " << flush;

	ifstream fin("ListTest1.txt");
	assert( fin.is_open() );

	List<double> list0;
	List<double> list1;
	list0.readFrom(fin);
	list1.readFrom(fin);

	List<double>::Node* l0Ptr = list0.myFirst;
	List<double>::Node* l1Ptr = list1.myFirst;

	for (unsigned i = 1; i < 6; i++) {
		assert( l0Ptr->myItem == i );
		assert( l1Ptr->myItem == (2*i) );
		l0Ptr = l0Ptr->myNext;
		l1Ptr = l1Ptr->myNext;
	}
	fin.close();
	cout << " 0 " << flush;

	cout << "Passed!" << endl;
}


void ListTester::testWriteToString() {
	cout << "Testing writeTo(string)... " << flush;

	List<double> list0;
	List<double> list1;
	for (unsigned i = 1; i < 6; i++) {
		list0.append(i);
		list1.append(i*2);
	}
	list0.writeTo("ListTestWrite1.txt");
	list1.writeTo("ListTestWrite2.txt");

	ifstream fin1("ListTestWrite1.txt");
	ifstream fin2("ListTestWrite2.txt");

	double list1Item, list2Item;

	for (unsigned i = 1; i < 6; i++) {
		fin1 >> list1Item;
		fin2 >> list2Item;
		assert( list1Item == i );
		assert( list2Item == i*2 );
	}


	fin1.close();
	fin2.close();

	cout << "Passed!" << endl;
}


void ListTester::testPrepend() {
	cout << "Testing prepend()... " << flush;
	// The empty case
	List<double> list0;
	list0.prepend(1);
	assert( list0.myFirst != NULL );
	assert( list0.myLast != NULL );
	assert( list0.myFirst == list0.myLast );
	assert( list0.myFirst->myItem == 1 );
	assert( list0.myFirst->myNext == NULL);
	cout << " 0 " << flush;

	// Non-empty case
	list0.prepend(3);
	assert( list0.myFirst != NULL );
	assert( list0.myLast != NULL );
	assert( list0.myFirst != list0.myLast );
	assert( list0.myFirst->myItem == 3 );
	assert( list0.myFirst->myNext == list0.myLast);
	assert( list0.myFirst->myNext->myItem == list0.myLast->myItem );
	assert( list0.myLast->myItem == 1);
	assert( list0.myLast == list0.myFirst->myNext );
	cout << " 1 " << flush;

	cout << "Passed!" << endl;
}


void ListTester::testInsert() {
	cout << "Testing insert()..." << flush;
	// Empty case
	List<double> list;
	list.insert(5, 0);
	assert( list.myFirst != NULL );
	assert( list.myLast != NULL );
	assert( list.myFirst == list.myLast );
	assert( list.myFirst->myItem == 5 );
	assert( list.myFirst->myNext == NULL);
	assert( list.mySize == 1);
	cout << " 0 " << flush;

	// Non-empty index too large
	list.insert(6, 2000);
	assert( list.myFirst != list.myLast );
	assert( list.myFirst->myItem == 5 );
	assert( list.myLast->myItem == 6 );
	assert( list.myFirst->myNext == list.myLast);
	assert( list.myFirst->myNext->myItem == 6 );
	assert( list.myFirst->myNext->myNext == NULL );
	assert( list.mySize == 2);
	cout << " 1 " << flush;

	// Non-empty index negative
	list.insert(4, -1000);
	assert( list.myFirst->myItem == 4 );
	assert( list.myLast->myItem == 6 );
	assert( list.myFirst->myNext->myNext == list.myLast);
	assert( list.myFirst->myNext->myItem == 5 );
	assert( list.myFirst->myNext->myNext->myItem == 6 );
	assert( list.myFirst->myNext->myNext->myNext == NULL );
	assert( list.mySize == 3);
	cout << " 2 " << flush;

	// Non-empty index 0
	list.insert(3,0);
	assert( list.myFirst->myItem == 3 );
	assert( list.myLast->myItem == 6 );
	assert( list.myFirst->myNext->myNext->myNext == list.myLast);
	assert( list.myFirst->myNext->myItem == 4 );
	assert( list.myFirst->myNext->myNext->myItem == 5 );
	assert( list.myFirst->myNext->myNext->myNext->myItem == 6 );
	assert( list.myFirst->myNext->myNext->myNext->myNext == NULL );
	assert( list.mySize == 4);
	cout << " 3 " << flush;

	// Non-empty in range index
	list.insert(20, 2);
	assert( list.myFirst->myItem == 3 );
	assert( list.myLast->myItem == 6 );
	assert( list.myFirst->myNext->myNext->myNext->myNext == list.myLast);
	assert( list.myFirst->myNext->myItem == 4 );
	assert( list.myFirst->myNext->myNext->myItem == 20 );
	assert( list.myFirst->myNext->myNext->myNext->myItem == 5 );
	assert( list.myFirst->myNext->myNext->myNext->myNext->myItem == 6 );
	assert( list.myFirst->myNext->myNext->myNext->myNext->myNext == NULL );
	assert( list.mySize == 5);
	cout << " 4 " << flush;

	cout << "Passed!" << endl;
}



void ListTester::testInequality() {
    cout << "Testing Inequality... " << flush;
    //Work on empty?
    List<double> l1;
    List<double> l2;
    assert (!( l1 != l2 ));
    cout << " 0 " << flush;
    //Works on same? (Using not not equal to.)
    l1.append(11);
    l1.append(22);
    l1.append(33);
    l2.append(11);
    l2.append(22);
    l2.append(33);
    assert (!( l1 != l2 ));
    cout << " 1 " << flush;
    //Works on different sizes?
    l2.append(33);
    assert ( l1 != l2 );
    cout << " 2 " << flush;
    cout << "Passed! " << endl;
}

void ListTester::testWriteToStream() {
    cout << "Testing writeTo(ostream)... " << flush;
    //Works normally?
    List<double> l1;
    l1.append(11);
    l1.append(22);
    l1.append(33);
    ofstream fout("lab05CoutTest.txt");
    assert( fout.is_open() );
    l1.writeTo(fout, "\t");
    fout.close();
    fstream fin("lab05CoutTest.txt");
    assert( fin.is_open() );
    string testLine;
    getline(fin, testLine);
//    cout<<testLine<<endl;
    assert (testLine == "11	22	33");
    fin.close();
    cout << " 0 " << flush;
    //Works with newlines?
    List<double> l2;
    l2.append(5);
    l2.append(67);
    l2.append(103);
    ofstream bout("lab05CoutTest.txt");
    assert( bout.is_open() );
    l2.writeTo(bout, "\n");
    bout.close();
    fstream bin("lab05CoutTest.txt");
    assert( bin.is_open() );
    getline(bin, testLine);
    assert (testLine == "5");
    getline(bin, testLine);
    assert (testLine == "67");
    getline(bin, testLine);
    assert (testLine == "103");
    bin.close();
    cout << " 1 " << flush;
    //Works on empty lists?
    List<double> l3;
    ofstream hout("lab05CoutTest.txt");
    assert( hout.is_open() );
    l3.writeTo(hout, "\t");
    hout.close();
    fstream hin("lab05CoutTest.txt");
    assert( hin.is_open() );
    getline(hin, testLine);
    assert (testLine == "");
    hin.close();
    cout << " 2 " << flush;
    cout << "Passed! " << endl;
}


void ListTester::testReadFromString() {
    cout << "Testing readFrom(string)... " << flush;
    //Works on regular cases?
    List<double> l1;
    l1.append(11);
    l1.append(22);
    l1.append(33);
    l1.append(44);
    ofstream fout("lab05ReadStringTest.txt");
    assert( fout.is_open() );
    l1.writeTo(fout, "\t");
    List<double> l2;
    fout.close();
    l2.readFrom("lab05ReadStringTest.txt");
    assert(!(l1 != l2));
    cout << " 0 " << flush;
    //Works with empty lists?
    List<double> l3;
    ofstream bout("lab05ReadStringTest.txt");
    l3.writeTo(bout, "\t");
    List<double> l4;
    bout.close();
    l4.readFrom("lab05ReadStringTest.txt");
    assert(!(l3 != l4));
    cout << " 1 " << flush;
    //Works with newlines?
    List<double> l5;
    l1.append(3);
    l1.append(46);
    l1.append(369);
    ofstream hout("lab05ReadStringTest.txt");
    l5.writeTo(hout, "\n");
    List<double> l6;
    hout.close();
    l6.readFrom("lab05ReadStringTest.txt");
    assert(!(l5 != l6));
    cout << " 2 " << flush;
    cout << "Passed! " << endl;
}



void ListTester::testGetIndexOf() {
    cout << "Testing getIndexOf()... " << flush;
    //Works on regular cases?
    List<double> l1;
    l1.append(11);
    l1.append(22);
    l1.append(33);
    assert(l1.getIndexOf(22) == 1);
    cout << " 0 " << flush;
    //Works on size 0?
    List<double> l2;
    assert(l2.getIndexOf(22) == -1);
    cout << " 1 " << flush;
    //Works when value not found?
    assert(l1.getIndexOf(44) == -1);
    cout << " 2 " << flush;
    cout << "Passed! " << endl;
}

void ListTester::testRemove() {
    cout << "Testing testRemove()... " << flush;
    //Works on size 1?
    List<double> l5, l6;
    l5.append(11);
    //Test that remove also returns the value of Item deleted.
    assert(l5.remove(1) == 11);
    assert(!(l5 != l6));
    cout << " 0 " << flush;
    //Works on first value?
    List<double> l1;
    l1.append(11);
    l1.append(22);
    l1.append(33);
    l1.append(44);
    List<double> l2;
    l2.append(22);
    l2.append(33);
    l2.append(44);
    assert(l1.remove(0) == 11);
    assert(!(l1 != l2));
    cout << " 1 " << flush;
    //Works on last value?
    List<double> l3;
    l3.append(11);
    l3.append(22);
    l3.append(33);
    l3.append(44);
    List<double> l4;
    l4.append(11);
    l4.append(22);
    l4.append(33);
    assert(l3.remove(4) == 44);
    assert(!(l3 != l4));
    cout << " 2 " << flush;
    //Works on point in the middle that is not first, nor last, nor the only value in list?
    List<double> l7;
    l7.append(1); //index = 0
    l7.append(2); //index = 1
    l7.append(3); //index = 2
    l7.append(4); //index = 3, to be removed.
    l7.append(5); //index = 4
    l7.append(6); //index = 5
    List<double> l8;
    l8.append(1);
    l8.append(2);
    l8.append(3);
    l8.append(5);
    l8.append(6);
    assert(l7.remove(3) == 3);
    assert(!(l7 != l8));
    cout << " 3 " << flush;
    //Works on size 0?
    List<double> l9;
    List<double> l10;
    l9.writeTo(cout, " ");
    l10.writeTo(cout, " ");
    assert(l9.remove(100) == -1);
    assert(!(l9 != l10));
    cout << " 4 " << flush;
    cout << "Passed! " << endl;
}

void ListTester::testInsertAfter(){
	cout << "Testing testInsertAfter()... " << flush;
	List<string> congaLine;
	congaLine.append("Ann");
	congaLine.append("Bob");
	//Works when person not in line?
	congaLine.insertAfter("F", "Alex");
//	congaLine.writeTo(cout, " ");
	assert (congaLine.mySize == 2);
	cout << " 0 " << flush;
	//Works when person in line?
	congaLine.insertAfter("Ann", "Alex");
//	congaLine.writeTo(cout, " ");
	assert (congaLine.mySize == 3);
	assert (congaLine.myFirst->myNext->myItem == "Alex");
	cout << " 1 " << flush;
	cout << "Passed! " << endl;
}

void ListTester::testInsertBefore() {
	cout << "Testing testInsertBefore()... " << flush;
	List<string> congaLine;
	congaLine.append("Ann");
	congaLine.append("Bob");
	//Works when person not in line?
	congaLine.insertBefore("F", "Alex");
//	congaLine.writeTo(cout, " ");
	assert (congaLine.mySize == 2);
	cout << " 0 " << flush;
	//Works when person in line?
	congaLine.insertBefore("Ann", "Alex");
//	congaLine.writeTo(cout, " ");
	assert (congaLine.mySize == 3);
	assert (congaLine.myFirst->myItem == "Alex");
	cout << " 1 " << flush;
	cout << "Passed! " << endl;
}

void ListTester::testOutput() {
	cout << "Testing testOutput()... " << flush;
	List<string> congaLine;
	congaLine.append("Ann");
	congaLine.append("Bob");
	congaLine.append("Chris");
	congaLine.append("Don");

    ofstream fout("conga.txt");
    assert( fout.is_open() );
    fout << congaLine << "=Evan";
    //Testing the ability to chain with << by having another value follow congaLine.
    fout.close();

    fstream fin("conga.txt");
    assert( fin.is_open() );
    string testLine;
    getline(fin, testLine);
//    cout<<testLine<<endl;
    assert (testLine == "=Ann=Bob=Chris=Don=Evan");
    fin.close();

	cout << " 0 " << flush;
	cout << "Passed! " << endl;
}
=Ann=Bob=Chris=Don=Evan1 2 3 4 5
2 4 6 8 101
2
3
4
5
2
4
6
8
10
]0;aaf25@maroon17: ~/cs112/proj06[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06[00m$ [Kcd de  DEb  ebug
]0;aaf25@maroon17: ~/cs112/proj06/Debug[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06/Debug[00m$ ls
CongaLine.d  ListTester.d  main.d  makefile    [0m[01;32mproj06[0m      subdir.mk
CongaLine.o  ListTester.o  main.o  objects.mk  sources.mk
]0;aaf25@maroon17: ~/cs112/proj06/Debug[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06/Debug[00m$ make all
make: Nothing to be done for 'all'.
]0;aaf25@maroon17: ~/cs112/proj06/Debug[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06/Debug[00m$ cd ..
]0;aaf25@maroon17: ~/cs112/proj06[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06[00m$ ./Debug/P proj06
Running List tests...
Testing List default constructor... Passed!
Testing Node default constructor... Passed!
Testing Node explicit constructor...  1  2 Passed!
Testing append()...  0a  0b  1  2  3 Passed!
Testing destructor...  1  2 Passed!  But double-check for memory leaks!
Testing copy constructor...  1  2 Passed!
Testing assignment...  1  2  3  4  5  6  7 Passed!  But double-check for memory leaks!
Testing equality...  0  1  2  3 Passed!
Testing readFrom(istream)...  0 Passed!
Testing writeTo(string)... Passed!
Testing prepend()...  0  1 Passed!
Testing insert()... 0  1  2  3  4 Passed!
Testing Inequality...  0  1  2 Passed! 
Testing writeTo(ostream)...  0  1  2 Passed! 
Testing readFrom(string)...  0  1  2 Passed! 
Testing getIndexOf()...  0  1  2 Passed! 
Testing testRemove()...  0  1  2  3  4 Passed! 
Testing testInsertAfter()...  0  1 Passed! 
Testing testInsertBefore()...  0  1 Passed! 
Testing testOutput()...  0 Passed! 
All tests passed!
Ann and Bob have started a Conga Line!
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 1

What is your name? Chris
=Ann=Bob=Chris
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 2

What is your name? Don
Who do you want to follow? Ann
=Ann=Don=Bob=Chris
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 2

What is your name? Eve
Who do you want to follow? Bob
=Ann=Don=Bob=Eve=Chris
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 2F 

What is your name? Fred
Who do you want to follow? Chris
=Ann=Don=Bob=Eve=Chris=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 3

What is your name? Hal9000
Who do you want to precede? Eve
=Ann=Don=Bob=Hal9000=Eve=Chris=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 3

What is your name? Gwen
Who do you want to precede? Ann
=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 3

What is your name? Ivy
Who do you want to precede? Fred
=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Ivy=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 2

What is your name? Joe
Who do you want to follow? Bilbo

***Bilbo is not dancing!

=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Ivy=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 3

What is your name? Jon
Who do you want to precede? Frodo

***Frodo is not dancing!

=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Ivy=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 0

*** 0 is not a valid choice!

=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Ivy=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 5

*** 5 is not a valid choice!

=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Ivy=Fred
Conga, Conga, Con-GA!  Conga, Conga, Con-GA!

Please enter:
 1 to join the Conga line at the end
 2 to join the Conga line after a particular person
 3 to join the Conga line before a particular person
 4 to quit
--> 4

The dance is done!
=Gwen=Ann=Don=Bob=Hal9000=Eve=Chris=Ivy=Fred
]0;aaf25@maroon17: ~/cs112/proj06[01;32maaf25@maroon17[00m:[01;34m~/cs112/proj06[00m$ exit

Script done on 2019-10-17 11:17:12-0400
